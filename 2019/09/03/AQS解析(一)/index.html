<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="https://angular.cn/assets/images/favicons/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="https://angular.cn/assets/images/favicons/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="https://angular.cn/assets/images/favicons/favicon.ico">
  <link rel="mask-icon" href="https://angular.cn/assets/images/favicons/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.annwyn.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="AbstractQueuedSynchronizer (以下简写 AQS )这个抽象类是用来构建锁或者其他同步组件的基础框架, 使用一个 int 成员变量来表示同步状态, 通过内置的 FIFO 同步队列来控制获取共享资源的线程.">
<meta property="og:type" content="article">
<meta property="og:title" content="AQS解析(一)">
<meta property="og:url" content="http://blog.annwyn.top/2019/09/03/AQS%E8%A7%A3%E6%9E%90(%E4%B8%80)/index.html">
<meta property="og:site_name" content="江湖夜雨十年灯">
<meta property="og:description" content="AbstractQueuedSynchronizer (以下简写 AQS )这个抽象类是用来构建锁或者其他同步组件的基础框架, 使用一个 int 成员变量来表示同步状态, 通过内置的 FIFO 同步队列来控制获取共享资源的线程.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.niupic.com/images/2019/10/30/_1750.png">
<meta property="og:image" content="https://i.niupic.com/images/2019/10/30/_1759.png">
<meta property="og:image" content="https://i.niupic.com/images/2019/10/30/_1760.png">
<meta property="og:image" content="https://i.niupic.com/images/2019/10/30/_1778.png">
<meta property="og:image" content="https://i.niupic.com/images/2019/10/30/_1779.png">
<meta property="og:image" content="https://i.niupic.com/images/2019/10/30/_1791.png">
<meta property="og:image" content="https://i.niupic.com/images/2019/10/30/_1792.png">
<meta property="og:image" content="https://i.niupic.com/images/2019/10/30/_1810.png">
<meta property="article:published_time" content="2019-09-03T06:17:22.000Z">
<meta property="article:modified_time" content="2019-09-03T06:17:22.000Z">
<meta property="article:author" content="annwyn">
<meta property="article:tag" content="annwyn&#39;s blog, 江湖夜雨十年灯">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.niupic.com/images/2019/10/30/_1750.png">

<link rel="canonical" href="http://blog.annwyn.top/2019/09/03/AQS%E8%A7%A3%E6%9E%90(%E4%B8%80)/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>AQS解析(一) | 江湖夜雨十年灯</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?265851578f490fe37a161d34103e30fd";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">江湖夜雨十年灯</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">29</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.annwyn.top/2019/09/03/AQS%E8%A7%A3%E6%9E%90(%E4%B8%80)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ftp.bmp.ovh/imgs/2020/03/535306740c08aa98.webp">
      <meta itemprop="name" content="annwyn">
      <meta itemprop="description" content="annwyn's blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江湖夜雨十年灯">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          AQS解析(一)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-03 14:17:22" itemprop="dateCreated datePublished" datetime="2019-09-03T14:17:22+08:00">2019-09-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>AbstractQueuedSynchronizer (以下简写 AQS )这个抽象类是用来构建锁或者其他同步组件的基础框架, 使用一个 int 成员变量来表示同步状态, 通过内置的 FIFO 同步队列来控制获取共享资源的线程.</p>
<span id="more"></span>
<h3 id="1-Lock接口介绍"><a href="#1-Lock接口介绍" class="headerlink" title="1. Lock接口介绍"></a>1. Lock接口介绍</h3><p>Lock 接口实现类提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作, 此实现允许更灵活的结构, 可以具有差别很大的属性, 可以支持多个相关的 Condition (Condition 用于实现线程的通知/与唤醒机制)对象. </p>
<p>锁是用于控制多线程访问共享资源的工具. 通常, 锁提供对共享资源的独占访问: 一次只有一个线程可以获取锁, 对共享资源的所有访问都需要首先获取锁. 但是, 一些锁可以允许同时访问共享资源, 例如 ReadWriteLock. 虽然使用关键字 synchronized 修饰的方法或代码块, 会使得在监视器模式 (ObjectMonitor) 下编程变得非常容易(通过 synchronized 块或者方法所提供的隐式获取释放锁的便捷性). 虽然这种方式简化了锁的管理, 但是某些情况下, 还是建议采用 Lock 接口(及其相关子类)提供的显示的锁的获取和释放. </p>
<p>例如, 针对一个场景, 手把手进行锁获取和释放, 先获得锁 A, 然后再获取锁 B, 当锁 B 获得后, 释放锁 A 同时获取锁 C, 当锁 C 获得后, 再释放 B 同时获取锁 D, 以此类推. 这种场景下, synchronized 关键字就不那么容易实现了, 而 Lock 接口的实现类允许锁在不同的作用范围内获取和释放, 并允许以任何顺序获取和释放多个锁. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取锁, 如果当前锁不可用, 当前线程将会处于阻塞状态, 直到获取锁.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 可中断的获取锁, 与lock方法不同的是该方法可以响应中断.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">// 尝试非阻塞方式获取锁, 调用该方法后立即返回是否成功获取锁.</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 在一定的时间内尝试获取锁. </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 获取等待通知组件, 该组件与当前锁进行绑定.</span></span><br><span class="line">    <span class="comment">// 当前线程只有拥有了锁, 才能调用组件的wait方法. 当调用wait方法后, 当前线程也将释放锁</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 Lock 类的方法中可以看到与 synchronized 的区别:</p>
<ol>
<li>尝试非阻塞地获取锁: 当线程尝试获取锁, 如果这一时刻锁没有被其他线程获取到, 则成功获取并持有锁. </li>
<li>能被中断的获取锁: 与 synchronized 不同, 获取到锁的线程能够响应中断, 当获取到锁的线程被中断时, 中断异常会被抛出, 同时锁也会被释放. </li>
<li>超时获取锁: 在指定的截止时间之前获取锁, 如果截止时间到了任然无法获取到锁, 则返回. </li>
</ol>
<p>Lock 类的使用方式也比较简单, 以下举例 ReentrantLock 的使用方式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.reentrantLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.reentrantLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看 Lock 的实现类, 可以发现, AbstractQueuedSynchronizer (AQS) 是实现的关键. 从代码上看, Lock 接口是面向使用者的, 它定义了使用者与锁交互的接口, 隐藏了实现细节. AQS 与 Condition 才是真正的实现, 它简化了锁的实现方式, 屏蔽了同步状态的管理、线程排队、等待与唤醒等底层操作.</p>
<h3 id="2-AQS-简介与代码分析"><a href="#2-AQS-简介与代码分析" class="headerlink" title="2. AQS 简介与代码分析"></a>2. AQS 简介与代码分析</h3><h4 id="2-1-AQS-简介"><a href="#2-1-AQS-简介" class="headerlink" title="2.1 AQS 简介"></a>2.1 AQS 简介</h4><p>AQS 被设计为大多数同步组件的基类, 这些同步组件都依赖于单个原子值 (int) 来控制同步状态, 子类必须要定义获取获取同步与释放状态的方法, 在AQS 中提供了三种方法 getState()、 setState(int newState) 及 compareAndSetState(int expect, int update) 来进行操作. </p>
<p>AQS 自身没有实现任何同步接口, 它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用, 同步器既可以支持独占式地获取同步状态, 也可以支持共享式地获取同步状态, 这样就可以方便实现不同类型的同步组件 (ReentrantLock、ReentrantReadWriteLock 和 CountDownLatch 等). </p>
<p>AQS 的设计是基于模板方法模式的, 也就是说, 使用者需要继承同步器并重写指定的方法, 随后将同步器组合在自定义同步组件的实现中, 并调用同步器提供的模板方法, 而这些模板方法将会调用使用者重写的方法. 先看下 AQS 中有哪些属性以及部分方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head; <span class="comment">// 头结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail; <span class="comment">// 尾节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个是最重要的, 代表当前锁的状态, 0代表没有被占用, 大于 0 代表有线程持有当前锁</span></span><br><span class="line">    <span class="comment">// 这个值可以大于 1, 是因为锁可以重入, 每次重入都加上 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该属性继承自AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="comment">// 代表当前持有独占锁的线程, 举个最重要的使用例子, 因为锁可以重入, 所以每次用这个来判断当前线程是否已经拥有了锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 独占式尝试获取同步状态, 通过CAS操作设置同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 独占式获取同步状态, 如果当前线程获取同步状态成功, 则返回, 否则进入同步队列等待, 该方法会调用tryAcquire(int arg)方法. </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 AQS 中主要通过一个 FIFO 来控制线程的同步. 那么在实际程序中, AQS 会将获取同步状态的线程构造成一个 Node 节点, 并将该节点加入到队列中. 如果该线程获取同步状态失败会阻塞该线程, 当同步状态释放时, 会把头节点中的线程唤醒, 使其尝试获取同步状态. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node(); <span class="comment">// 标识节点当前在共享模式下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>; <span class="comment">// 标识节点当前在独占模式下</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus; </span><br><span class="line">    <span class="comment">// ======== 下面的几个int常量是给waitStatus用的 ===========</span></span><br><span class="line">    <span class="comment">// 因为超时或者中断, Node被设置为取消状态, 被取消的Node不应该去竞争锁, 只能保持取消状态不变, 不能转换为其他状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>; </span><br><span class="line">    <span class="comment">// 当前一个节点的线程如果释放或者取消了同步状态, 将会将当前一个节点状态设置为SIGNAL, 用于通知下一个节点准备获取同步状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>; </span><br><span class="line">    <span class="comment">// 表示这个Node在Condition的等待队列中, 其他线程调用Condition的singal方法后, 该节点会从等待队列转移到AQS的同步队列中, 等待获取同步锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 与共享式获取同步状态有关, 表示锁的下一次获取可以无条件传播</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> Node prev; <span class="comment">// 上一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next; <span class="comment">// 下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread; <span class="comment">// 当前一个节点对应的线程, 表示等待锁的线程</span></span><br><span class="line">    Node nextWaiter; <span class="comment">// 当前一个节点在Condition中等待队列上的下一个节点</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 AQS 中的同步队列, 分别有两个指针(对象), 一个 head 指向队列的头节点, 一个 tail 指向队列的尾节点. </p>
<p>当一个线程成功获取了同步状态(或者锁), 其他线程无法获取到同步状态, 这个时候会将该线程构造成 Node 节点, 并加入到同步队列中, 而这个加入队列的过程必须要确保线程安全, 所以在 AQS 中提供了一个基于 CAS 的设置尾节点的方法: compareAndSetTail(Node expect, Node update), 它需要传递当前线程“认为”的尾节点和当前一个节点, 只有设置成功后, 当前一个节点才正式与之前的尾节点建立关联. </p>
<p>在 AQS 中的同步队列中, 头节点是获取同步状态成功的节点, 头节点的线程会在释放同步状态时, 唤醒其下一个节点, 而下一个节点会在获取同步状态成功时将自己设置为头节点.<br><img src="https://i.niupic.com/images/2019/10/30/_1750.png" alt="1"></p>
<h4 id="2-2-AQS-代码分析"><a href="#2-2-AQS-代码分析" class="headerlink" title="2.2 AQS 代码分析"></a>2.2 AQS 代码分析</h4><p>ReentrantLock 在内部用了内部类 Sync 来管理锁, 所以真正的获取锁和释放锁是由 AQS 的实现类 Sync 来控制的. Sync 有两个实现, 分别为 NonfairSync (非公平锁)和  FairSync (公平锁):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下分析 ReentrantLock 中的 NonfairSync (非公平锁)的加锁实现部分, 可以从 NonfairSync 的 lock 方法开始跟踪代码. 以下是 Lock 加锁过程中的实现代码: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">// 尝试修改state</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread()); <span class="comment">// 如果能成功上锁, 将持有锁的线程设定为当前线程</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>); <span class="comment">// 尝试获取锁, 直接查看AQS的acquire方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 因为是非公平锁, 直接尝试获取锁. 如果能直接获取到锁, 设定当前持有锁的线程. </span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current); <span class="comment">// 获取到锁之后, 标记下锁被当前线程获取了.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; </span><br><span class="line">            <span class="comment">// 进入这个分支说明锁重入了, 需要将state + 1</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 代码运行到此处, 说明没有获取到锁. 将进入acquireQueued方法中.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">// 此时, arg == 1</span></span><br><span class="line">        <span class="comment">// 首先调用tryAcquire(子类中实现)方法尝试获取锁, 因为有可能直接就成功了, 不需要进队列排队.</span></span><br><span class="line">        <span class="comment">// 如果无法获取锁, 这时候就需要调用acquireQueued方法把线程挂起, 放入阻塞队列中.</span></span><br><span class="line">        <span class="comment">// 如果没有线程获取过锁, 那么tryAcquire方法直接返回true, acquire方法也就结束了.</span></span><br><span class="line">        <span class="comment">// 否则acquireQueued方法会将线程加到队列中的队尾</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="comment">// </span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该方法的作用是将线程包装成Node对象, 同时加入到队列中.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123; <span class="comment">// 此时参数mode为Node.EXCLUSIVE, 代表独占模式.</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// 以下几行代码是把当前Node加到链表的最后面去, 也就是进到阻塞队列的最后.</span></span><br><span class="line">        Node pred = tail; <span class="comment">// 尾节点, 第一次入队时, head和tail都未初始化.</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred; <span class="comment">// 记录当前一个节点的上一个节点为原队列的尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; <span class="comment">// 用CAS把自己设置为尾节点. 如果设置成功, 这个节点就是阻塞队列的末尾节点</span></span><br><span class="line">                pred.next = node; <span class="comment">// 设置原尾节点的下一节点为当前一个节点</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node); <span class="comment">// 运行到此处说明: 队尾为空(队列为空)或者CAS设置尾节点失败</span></span><br><span class="line">        <span class="keyword">return</span> node; <span class="comment">// 返回当前一个节点, 进入acquireQueued方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 采用自旋(死循环)方式入队: 在CAS设置尾节点的过程中, 如果CAS操作返回失败, 那么就尝试CAS操作直到成功为止.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 只有入队成功才会跳出循环</span></span><br><span class="line">            Node t = tail; <span class="comment">// 尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 队列为空的情况下</span></span><br><span class="line">                <span class="comment">// 需要注意的是此处调用compareAndSetHead方法时传入的参数.</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) <span class="comment">// 此时的head应该为null, 此处用CAS方式设定head</span></span><br><span class="line">                    <span class="comment">// 注意此处设定head之后并没有直接return, 还是要继续执行for循环, 进入else分支才会中断循环</span></span><br><span class="line">                    tail = head; <span class="comment">// 此处设定队尾(指向了同一个Node).</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 在这个else分支中, 主要是设定当前一个节点的前后节点和使用CAS设定尾节点</span></span><br><span class="line">                node.prev = t; <span class="comment">// 设定当前一个节点的上一个节点是尾节点.</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="comment">// 在一个无限循环中, 将当前一个节点设定为队尾, 一直到设定成功为止.</span></span><br><span class="line">                    <span class="comment">// 此时CAS设定队尾已经成功, tail已经是本方法的参数node, head和tail已经不是相同的node了. </span></span><br><span class="line">                    t.next = node; <span class="comment">// 此时设定原队尾的下一个节点为当前一个节点</span></span><br><span class="line">                    <span class="keyword">return</span> t; <span class="comment">// 此处返回的是原队尾, 不是node. </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该方法是整个多线程竞争同步状态的关键方法.</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">// node是当前线程对应的节点</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">// 该方法获取当前一个节点的上一个节点.</span></span><br><span class="line">                <span class="comment">// 如果node是队列中的第一个节点(除了head), 那么先尝试获取锁</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node); <span class="comment">// 如果获取到锁, 将当前一个节点设定为head, 调用该方法会删除node的thread和上一个节点内容.</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 运行到此处说明当前node不是头(除去head)或者获取锁没抢赢别的线程, 判断线程是否需要阻塞.</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 线程被中断或者其他未知异常而进入到finally中</span></span><br><span class="line">            <span class="keyword">if</span> (failed) <span class="comment">// 被中断的情况下进入if分支, 将线程从同步队列中移除, 同时唤醒下一个节点</span></span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进入该方法说明线程没有获取到锁, 根据该方法的返回值判断是否需要挂起当前线程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus; <span class="comment">// 此处的ws是前一个节点的状态</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL) <span class="comment">// waitStatus == -1, 说明前一个节点状态正常, 当前线程需要阻塞.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123; <span class="comment">// 大于0表示前一个节点取消了排队. 会被直接提出队列中.</span></span><br><span class="line">            <span class="comment">// 此处需要注意一点: 进入阻塞队列排队的线程会被挂起, 而唤醒线程的操作则是由前一个节点完成的.</span></span><br><span class="line">            <span class="comment">// 此处代码的意思是: 将当前一个节点的前一个节点指向一个waitStatus &lt;= 0的节点, 到时候依靠它去唤醒自己.</span></span><br><span class="line">            <span class="keyword">do</span> &#123; </span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 代码运行到这边时, 都没有看到显示的设定过waitStatus, 所以每个node默认的waitStatus都是0.</span></span><br><span class="line">            <span class="comment">// 而运行到这个分支, waitStatus取值只能是0, -2, -3. 此处将前一个节点的waitStatus设置为Node.SIGNAL.</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 本方法到这边返回false, 继续执行acquireQueued方法的for循环, 然后再次进入本方法, 运行到第一个if并返回true.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个方法很简单, 因为shouldParkAfterFailedAcquire方法返回true, 所以需要阻塞线程, 这个方法就是负责阻塞线程的.</span></span><br><span class="line">    <span class="comment">// 这里用了LockSupport.park(this)来挂起线程, 然后就停在这里了, 等待被唤醒.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>); <span class="comment">// 线程阻塞</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进入该方法说明需要将线程从同步队列中移除.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        node.thread = <span class="keyword">null</span>; <span class="comment">// 1. 将节点对应的线程设置为null</span></span><br><span class="line">        Node pred = node.prev;</span><br><span class="line">        <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>) <span class="comment">// 2. 跳过当前节点之前已经取消的节点</span></span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        Node predNext = pred.next;</span><br><span class="line">        node.waitStatus = Node.CANCELLED; <span class="comment">// 3. 当前线程状态设置为CANCELLED(1)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">            compareAndSetNext(pred, predNext, <span class="keyword">null</span>); <span class="comment">// 4. 如果当前中断的节点是尾节点, 那么将尾节点重新指向上一个节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ws; <span class="comment">// 5. 判断当前节点的上一个节点的状态, 如果是SINGAL或者设定为SINGAL成功, 那么移除当前节点</span></span><br><span class="line">            <span class="keyword">if</span> (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">                (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node next = node.next;</span><br><span class="line">                <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    compareAndSetNext(pred, predNext, next);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                unparkSuccessor(node); <span class="comment">// 6. 将该节点移除, 同时唤醒下一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            node.next = node; <span class="comment">// help GC</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) <span class="comment">// 重置该节点为初始状态</span></span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 下面的代码就是唤醒后续的节点, 但是有可能后续节点取消了等待状态.</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">// 判断下一节点的状态, 如果为Node.CANCELED状态, 则向前遍历, 获取最近的waitStatus &lt;= 0的节点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>) <span class="comment">//如果当前节点的下一个节点不为null, 则唤醒下一个节点中的线程. </span></span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> parkBlockerOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            parkBlockerOffset = UNSAFE.objectFieldOffset(Thread.class.getDeclaredField(<span class="string">&quot;parkBlocker&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞当前线程, 如果调用unpark方法或者当前线程被中断, 才能从park方法中返回.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>); <span class="comment">// 当线程阻塞时, 会阻塞在这边. 详细代码可以查看JVM的代码</span></span><br><span class="line">        setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBlocker</span><span class="params">(Thread t, Object arg)</span> </span>&#123;</span><br><span class="line">        UNSAFE.putObject(t, parkBlockerOffset, arg); <span class="comment">// 将当前线程中parkBlocker参数设定为参数arg</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下分析 ReentrantLock 中的 NonfairSync (非公平锁)的解锁实现部分, 可以从 NonfairSync 的 unlock 方法开始跟踪代码. 以下是 Lock 解锁过程中的实现代码: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; <span class="comment">// 此时unlock方法只有一个线程会进入. 其他线程都未拿到锁, 正在阻塞中.</span></span><br><span class="line">        sync.release(<span class="number">1</span>); <span class="comment">// 解锁, 此处调用AQS中的release方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">// 此处调用Sync中的tryRelease方法</span></span><br><span class="line">            Node h = head; <span class="comment">// 如果已经完全释放锁了, 进入这个判断中, 唤醒等待的线程.</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h); <span class="comment">// 查看加锁部分的代码解释</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>; <span class="comment">// 是否已经完全释放锁.</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 锁重入的问题</span></span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-ReentrantLock-加锁"><a href="#3-ReentrantLock-加锁" class="headerlink" title="3. ReentrantLock 加锁"></a>3. ReentrantLock 加锁</h3><p>假设线程1调用了 ReentrantLock 的 lock 方法, 那么线程1将会独占锁, 整个调用链十分简单:<br><img src="https://i.niupic.com/images/2019/10/30/_1759.png" alt="2"></p>
<p>线程1在调用 tryAcquire(1) 后直接返回 true, 内部先设定了 AQS 的 state 为 1, 之后设置 AQS 的 thread 为当前线程(此时并没有初始化 head 和 tail), 这两个操作完成后就表示线程1独占了锁.</p>
<p>之后线程2也要尝试获取同一个锁, 在线程1没有释放锁的情况下必然无法获取, 所以线程2被阻塞, 整个调用链比较复杂:<br><img src="https://i.niupic.com/images/2019/10/30/_1760.png" alt="3"></p>
<p>线程2先调用 lock 方法, 尝试修改 state, 当然这一步是必定失败的, 因此线程2直接调用 acquire 方法. 在 acquire 方法中, 首先调用 tryAcquire 方法尝试获取锁, 如果无法获取到锁, 继续走 acquireQueued 方法添加至 FIFO 等待队列中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先执行 AQS 的 addWaiter 方法, 如果队列为空的情况下, 初始化 head (直接调用 new Node()), 然后将当前线程封装成 Node 并加入到等待队列中. 之后调用 acquireQueued方法. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法是整个多线程竞争同步状态的关键方法.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">// node是当前线程对应的节点</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">// 该方法获取当前一个节点的上一个节点.</span></span><br><span class="line">            <span class="comment">// 如果node是队列中的第一个节点(除了head), 那么先尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node); <span class="comment">// 如果获取到锁, 将当前一个节点设定为head, 调用该方法会删除node的thread和上一个节点内容.</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 运行到此处说明当前node不是头(除去head)或者获取锁没抢赢别的线程, 判断线程是否需要阻塞.</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 线程被中断或者其他未知异常而进入到finally中</span></span><br><span class="line">        <span class="keyword">if</span> (failed) <span class="comment">// 被中断的情况下进入if分支, 将线程从同步队列中移除, 同时唤醒下一个节点</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过自旋的方式来获取同步状态，如果当前节点 (node1) 的上一节点是 head 且该节点获取同步状态成功，那么会设置 head 指向该节点 ，同时将上一节点的 next 指向断开。<br><img src="https://i.niupic.com/images/2019/10/30/_1778.png" alt="7"><br><img src="https://i.niupic.com/images/2019/10/30/_1779.png" alt="8"><br>此时由于线程2对应的 node 是等待队列中的第一个 Node (除去 head), 所以此时再尝试获取锁(可能线程1已经执行完成并释放了锁). 如果无法获取锁, 调用 shouldParkAfterFailedAcquire 方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程2进入 shouldParkAfterFailedAcquire 方法后, waitStatus 的状态是默认值 0, 所以此时直接将 waitStatus 设置为 Node.SIGNAL 即 -1 并返回 false. </p>
<p>分析 shouldParkAfterFailedAcquire 方法的返回值, 如果返回 true: 说明前一个节点的 waitStatus 是 -1, 是正常情况, 线程需要被挂起等待, 之后需要被唤醒. 那么如果返回 false: 说明不需要被挂起, 此时就会再次进入 acquireQueued 方法中的 for 循环, 然后会再次进入 shouldParkAfterFailedAcquire 方法. </p>
<p>仔细看 shouldParkAfterFailedAcquire 方法可以发现, 第一次进入该方法时, 必定返回 false. 原因很简单, 前一个节点的 waitStatus 的状态是依赖后续节点设置的 (shouldParkAfterFailedAcquire 方法可以结合解锁部分的代码一起阅读). 最后调用 parkAndCheckInterrupt 方法挂起线程.</p>
<blockquote>
<p>此时线程2入队, 然后调用 shouldParkAfterFailedAcquire 方法将 head 的 waitStatus 设定为-1, 而线程2的 waitStatus 并未设置, 还是为 0. 此时如果线程3再入队, 插入到线程2的后面, 此时线程3的 waitStatus 为 0, 当线程3调用 shouldParkAfterFailedAcquire 方法后, 会将线程2的 waitStatus 设置为-1.</p>
</blockquote>
<p>如果线程中断, 在 acquireQueued 方法中最终会执行 finally 语句中的代码, 通过 cancelAcquire 方法将线程从同步队列中移除.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    node.thread = <span class="keyword">null</span>; <span class="comment">// 1. 将节点对应的线程设置为null</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>) <span class="comment">// 2. 跳过当前节点之前已经取消的节点</span></span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line">    node.waitStatus = Node.CANCELLED; <span class="comment">// 3. 当前线程状态设置为CANCELLED(1)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>); <span class="comment">// 4. 如果当前中断的节点是尾节点, 那么将尾节点重新指向上一个节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ws; <span class="comment">// 5. 判断当前节点的上一个节点的状态, 如果是SINGAL或者设定为SINGAL成功, 那么移除当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">            (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node); <span class="comment">// 6. 将该节点移除, 同时唤醒下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>将节点对应的线程设置为 null</li>
<li>跳过当前节点之前已经取消的节点（我们已经知道在 Node.waitStatus 的枚举中，只有 CANCELLED 大于0 ）<br><img src="https://i.niupic.com/images/2019/10/30/_1791.png" alt="4"></li>
<li>当前线程状态设置为 CANCELLED(1)</li>
<li>如果当前中断的节点是尾节点, 那么则将尾节点重新指向上一个节点<br><img src="https://i.niupic.com/images/2019/10/30/_1792.png" alt="5"></li>
<li>判断当前节点的上一个节点的状态, 如果是 SINGAL 或者设定为 SINGAL 成功, 那么移除当前节点</li>
<li>如果5的条件不满足, 那么调用 unparkSuccessor 方法移除节点, 同时唤醒下一个节点<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) <span class="comment">// 重置该节点为初始状态</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 下面的代码就是唤醒后续的节点, 但是有可能后续节点取消了等待状态.</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 判断下一节点的状态, 如果为Node.CANCELED状态, 则向前遍历, 获取最近的waitStatus &lt;= 0的节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) <span class="comment">//如果当前节点的下一个节点不为null, 则唤醒下一个节点中的线程. </span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://i.niupic.com/images/2019/10/30/_1810.png" alt="6"></li>
</ol>
<h3 id="4-ReentrantLock-解锁"><a href="#4-ReentrantLock-解锁" class="headerlink" title="4. ReentrantLock 解锁"></a>4. ReentrantLock 解锁</h3><p>解锁的流程比较简单. 首先调用 ReentrantLock 的 unlock 方法, 内部直接调用 AQS 的 release 方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先调用 Sync 的 tryRelease 尝试释放锁, 只有当 c == 0 的时候才会真正释放锁, 这和加锁时一个线程多次调用 lock 方法累加 state 是对应的, 调用了多少次的 lock() 方法自然必须调用同样次数的 unlock() 方法才行, 这样才把一个锁给全部解开. </p>
<p>当线程对 ReentrantLock 全部解锁之后, AQS 的 state 自然就是 0 了, 方法返回 true. 代码运行到 unparkSuccessor 方法中, 进行唤醒线程已经移除当前节点与唤醒下一个节点.</p>
<h3 id="5-结尾"><a href="#5-结尾" class="headerlink" title="5. 结尾"></a>5. 结尾</h3><p>在并发状态下, 解锁和解锁需要三个部件的协调:</p>
<ol>
<li>锁状态: 如果需要知道锁是不是被别的线程占有了, 需要判断 state. 当为 0 时表示没有线程占有该锁, 所有线程都可以争抢这个锁. 当设定为 1, 说明这个锁已经被某个线程抢到了, 其他线程只能排队等待. 如果锁重入的话, state 进行累加即可. 当需要解锁的时候, state 进行递减直至为 0. 当 state 为 0 时表示线程已经完全释放锁了, 然后唤醒等待队列中的第一个线程.</li>
<li>线程的阻塞和唤醒: AQS 中使用 LockSupport 类进行线程的阻塞和唤醒.</li>
<li>阻塞队列: 因为可以有多个线程去争抢锁, 但只能有一个线程持有锁, 其他线程需要等待. 此时需要一个队列来管理等待的线程. AQS 中维护一个 FIFO 的链表, 每个 node 都持有后续节点的引用.</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/08/12/CAS%E8%A7%A3%E6%9E%90/" rel="prev" title="CAS解析">
      <i class="fa fa-chevron-left"></i> CAS解析
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/10/01/Spring%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/" rel="next" title="Spring常用工具类">
      Spring常用工具类 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Lock%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D"><span class="nav-text">1. Lock接口介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-AQS-%E7%AE%80%E4%BB%8B%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">2. AQS 简介与代码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-AQS-%E7%AE%80%E4%BB%8B"><span class="nav-text">2.1 AQS 简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-AQS-%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">2.2 AQS 代码分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-ReentrantLock-%E5%8A%A0%E9%94%81"><span class="nav-text">3. ReentrantLock 加锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-ReentrantLock-%E8%A7%A3%E9%94%81"><span class="nav-text">4. ReentrantLock 解锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E7%BB%93%E5%B0%BE"><span class="nav-text">5. 结尾</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="annwyn"
      src="https://ftp.bmp.ovh/imgs/2020/03/535306740c08aa98.webp">
  <p class="site-author-name" itemprop="name">annwyn</p>
  <div class="site-description" itemprop="description">annwyn's blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/annwynAval" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;annwynAval" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:296674162@qq.com" title="E-Mail → mailto:296674162@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">annwyn</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
